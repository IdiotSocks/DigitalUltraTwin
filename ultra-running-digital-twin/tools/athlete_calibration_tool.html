<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Athlete Calibration Tool - Digital Twin Ultra</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      background: white;
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .header h1 {
      font-size: 28px;
      font-weight: 900;
      color: #1f2937;
      margin-bottom: 8px;
    }

    .header p {
      font-size: 14px;
      color: #6b7280;
    }

    .card {
      background: white;
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .card-title {
      font-size: 18px;
      font-weight: 800;
      color: #1f2937;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #3b82f6;
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    .btn-success {
      background: #10b981;
      color: white;
    }

    .btn-success:hover {
      background: #059669;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .btn-secondary {
      background: #6b7280;
      color: white;
    }

    .btn-secondary:hover {
      background: #4b5563;
    }

    .upload-area {
      border: 2px dashed #d1d5db;
      border-radius: 12px;
      padding: 40px;
      text-align: center;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .upload-area:hover {
      border-color: #3b82f6;
      background: #f9fafb;
    }

    .upload-area.active {
      border-color: #10b981;
      background: #d1fae5;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th {
      background: #f9fafb;
      padding: 12px;
      text-align: left;
      font-weight: 700;
      color: #374151;
      border-bottom: 2px solid #e5e7eb;
    }

    td {
      padding: 12px;
      border-bottom: 1px solid #e5e7eb;
    }

    tr:hover {
      background: #f9fafb;
    }

    .accuracy-good {
      color: #10b981;
      font-weight: 700;
    }

    .accuracy-ok {
      color: #f59e0b;
      font-weight: 700;
    }

    .accuracy-bad {
      color: #ef4444;
      font-weight: 700;
    }

    .metric-box {
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      border: 2px solid #3b82f6;
    }

    .metric-label {
      font-size: 12px;
      color: #1e40af;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .metric-value {
      font-size: 32px;
      font-weight: 900;
      color: #1e3a8a;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      font-size: 12px;
      font-weight: 700;
      color: #374151;
      margin-bottom: 6px;
    }

    .form-input {
      width: 100%;
      padding: 10px;
      border: 2px solid #d1d5db;
      border-radius: 8px;
      font-size: 14px;
    }

    .form-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .form-select {
      width: 100%;
      padding: 10px;
      border: 2px solid #d1d5db;
      border-radius: 8px;
      font-size: 14px;
      background: white;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .grid-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
    }

    .grid-4 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 16px;
    }

    .badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
    }

    .badge-primary {
      background: #dbeafe;
      color: #1e40af;
    }

    .badge-success {
      background: #d1fae5;
      color: #065f46;
    }

    .badge-warning {
      background: #fef3c7;
      color: #92400e;
    }

    .hidden {
      display: none;
    }

    #chart-container {
      height: 300px;
      margin-top: 20px;
    }

    .action-buttons {
      display: flex;
      gap: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üîß Athlete Calibration Tool</h1>
      <p>Build and validate your athlete profile with race data to improve prediction accuracy</p>
    </div>

    <!-- Upload Profile -->
    <div class="card">
      <div class="card-title">üìÅ Load Athlete Profile</div>
      <input type="file" id="profileInput" accept=".json" style="display: none;">
      <button class="btn btn-primary" onclick="document.getElementById('profileInput').click()">
        Upload Athlete Profile JSON
      </button>
      <span id="profileStatus" style="margin-left: 16px; color: #6b7280;"></span>
    </div>

    <!-- Athlete Details -->
    <div class="card" id="athleteDetailsCard" style="display: none;">
      <div class="card-title">üë§ Athlete Details (Subjective)</div>
      <p style="font-size: 12px; color: #6b7280; margin-bottom: 16px;">Add qualitative information about your running style, strengths, and preferences. This helps contextualize your calibration data.</p>

      <div class="grid-2" style="margin-bottom: 16px;">
        <div>
          <label style="display: block; font-size: 12px; font-weight: 700; color: #374151; margin-bottom: 6px;">Name</label>
          <input type="text" id="athleteName" class="form-input" placeholder="e.g., Simbarashe">
        </div>
        <div>
          <label style="display: block; font-size: 12px; font-weight: 700; color: #374151; margin-bottom: 6px;">Location</label>
          <input type="text" id="athleteLocation" class="form-input" placeholder="e.g., Brighton, UK">
        </div>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="display: block; font-size: 12px; font-weight: 700; color: #374151; margin-bottom: 6px;">Primary Discipline</label>
        <input type="text" id="athleteDiscipline" class="form-input" placeholder="e.g., Ultra-trail running with marathon speed focus">
      </div>

      <div style="margin-bottom: 16px;">
        <label style="display: block; font-size: 12px; font-weight: 700; color: #374151; margin-bottom: 6px;">Strengths</label>
        <textarea id="athleteStrengths" class="form-input" rows="3" placeholder="e.g., Technical terrain (+15 percentile), Downhill descending, Pacing discipline, Marathon speed endurance"></textarea>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="display: block; font-size: 12px; font-weight: 700; color: #374151; margin-bottom: 6px;">Limiting Factors / Weaknesses</label>
        <textarea id="athleteLimitations" class="form-input" rows="3" placeholder="e.g., Exercise-induced asthma (temperature-triggered), Uphill power vs field, Cold weather performance (<8¬∞C)"></textarea>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="display: block; font-size: 12px; font-weight: 700; color: #374151; margin-bottom: 6px;">Racing Style / Notes</label>
        <textarea id="athleteNotes" class="form-input" rows="2" placeholder="e.g., Conservative starter, strong finisher, prefers runnable terrain"></textarea>
      </div>

      <button class="btn btn-primary" onclick="saveAthleteDetails()">üíæ Save Details</button>
    </div>

    <!-- Calibration Metrics -->
    <div class="card" id="metricsCard" style="display: none;">
      <div class="card-title">üìä Calibration Metrics</div>
      <div class="grid-4">
        <div class="metric-box">
          <div class="metric-label">Overall Factor</div>
          <div class="metric-value" id="overallFactor">--</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Mean Error</div>
          <div class="metric-value" id="meanError">--</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Total Races</div>
          <div class="metric-value" id="totalRaces">--</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Confidence</div>
          <div class="metric-value" id="confidence">--</div>
        </div>
      </div>

      <!-- Course Type Factors -->
      <div style="margin-top: 24px;">
        <h3 style="font-size: 14px; font-weight: 700; color: #374151; margin-bottom: 12px;">Calibration by Course Type</h3>
        <div class="grid-4" id="courseTypeFactors">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>

    <!-- Race Table -->
    <div class="card" id="raceTableCard" style="display: none;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <div class="card-title" style="margin-bottom: 0;">üèÉ Race History</div>
        <div>
          <button class="btn btn-success" onclick="showAddRaceModal()">+ Add Race</button>
          <button class="btn btn-primary" onclick="calculateCalibration()">üîÑ Recalculate</button>
          <button class="btn btn-secondary" onclick="exportProfile()">üíæ Export Profile</button>
        </div>
      </div>
      <div style="overflow-x: auto;">
        <table id="raceTable">
          <thead>
            <tr>
              <th>Primary</th>
              <th>Race Name</th>
              <th>Date</th>
              <th>Type</th>
              <th>Distance</th>
              <th>Elevation</th>
              <th>Actual Time</th>
              <th>Predicted Time</th>
              <th>Error %</th>
              <th>CTL</th>
              <th>Fitness</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="raceTableBody">
            <!-- Populated by JS -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- Chart -->
    <div class="card" id="chartCard" style="display: none;">
      <div class="card-title">üìà Prediction Accuracy</div>
      <p style="font-size: 12px; color: #6b7280; margin-bottom: 16px;">
        Comparing actual race times (blue) vs model predictions (green). Click <strong>"üîÑ Recalculate"</strong> to update.
      </p>
      <div style="height: 400px; position: relative; background: #f9fafb; border-radius: 8px; padding: 10px;">
        <canvas id="accuracyChart"></canvas>
        <div id="chartPlaceholder" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #9ca3af;">
          <div style="font-size: 48px; margin-bottom: 12px;">üìä</div>
          <div style="font-size: 14px; font-weight: 600;">Loading chart...</div>
          <div style="font-size: 12px; margin-top: 8px;">Click "üîÑ Recalculate" if chart doesn't appear</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Race Modal -->
  <div id="addRaceModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; padding: 20px; overflow-y: auto;">
    <div style="max-width: 800px; margin: 40px auto; background: white; border-radius: 16px; padding: 32px;">
      <h2 style="font-size: 24px; font-weight: 900; margin-bottom: 24px;">Add Race</h2>

      <div style="margin-bottom: 24px;">
        <button class="btn btn-primary" onclick="document.getElementById('gpxInput').click()">
          Upload GPX File
        </button>
        <span style="margin-left: 16px; color: #6b7280;">or enter manually below</span>
        <input type="file" id="gpxInput" accept=".gpx" style="display: none;">
      </div>

      <div class="grid-2">
        <div class="form-group">
          <label class="form-label">Race Name *</label>
          <input type="text" id="raceName" class="form-input" placeholder="e.g., UTMB 2025">
        </div>
        <div class="form-group">
          <label class="form-label">Date *</label>
          <input type="date" id="raceDate" class="form-input">
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Course Type *</label>
        <select id="courseType" class="form-select">
          <optgroup label="Road">
            <option value="road_5k">Road 5K</option>
            <option value="road_10k">Road 10K</option>
            <option value="road_half_marathon">Road Half Marathon</option>
            <option value="road_marathon">Road Marathon</option>
            <option value="road_ultra">Road Ultra (50k+)</option>
          </optgroup>
          <optgroup label="Trail - Flat/Runnable">
            <option value="flat_trail_short">Flat Trail (0-30k)</option>
            <option value="flat_trail_medium">Flat Trail (30-50k)</option>
            <option value="runnable_trail_40_80k">Runnable Trail (40-80k)</option>
          </optgroup>
          <optgroup label="Trail - Hilly">
            <option value="hilly_trail_short">Hilly Trail (0-30k)</option>
            <option value="hilly_trail_medium">Hilly Trail (30-50k)</option>
            <option value="hilly_trail_long">Hilly Trail (50-80k)</option>
          </optgroup>
          <optgroup label="Mountain/Technical">
            <option value="technical_mountain_50_70k">Technical Mountain (50-70k)</option>
            <option value="technical_mountain_long">Technical Mountain (70-100k)</option>
            <option value="alpine_ultra_150_200k">Alpine Ultra (150-200k)</option>
          </optgroup>
          <optgroup label="Fell/Vertical">
            <option value="fell_race">Fell Race</option>
            <option value="vertical_km">Vertical KM</option>
            <option value="skyrunning">Skyrunning</option>
          </optgroup>
        </select>
      </div>

      <div class="grid-3">
        <div class="form-group">
          <label class="form-label">Distance (km) *</label>
          <input type="number" id="raceDistance" class="form-input" placeholder="42.2" step="0.1">
        </div>
        <div class="form-group">
          <label class="form-label">Elevation Gain (m) *</label>
          <input type="number" id="raceElevation" class="form-input" placeholder="2000" step="1">
        </div>
        <div class="form-group">
          <label class="form-label">Finish Time (h:mm:ss) *</label>
          <input type="text" id="raceTime" class="form-input" placeholder="4:23:00">
        </div>
      </div>

      <div class="grid-2">
        <div class="form-group">
          <label class="form-label">CTL *</label>
          <input type="number" id="raceCTL" class="form-input" placeholder="146" step="1" oninput="calculateFitnessFromCTL()">
        </div>
        <div class="form-group">
          <label class="form-label">Fitness Level (auto-calculated)</label>
          <input type="number" id="raceFitness" class="form-input" placeholder="1.15" step="0.01" style="background: #f9fafb;">
          <div style="font-size: 10px; color: #6b7280; margin-top: 4px;">Auto-calculated from CTL. Can override manually.</div>
        </div>
      </div>

      <div class="grid-2">
        <div class="form-group">
          <label class="form-label">Temperature (¬∞C, optional)</label>
          <input type="number" id="raceTemp" class="form-input" placeholder="15" step="0.1">
        </div>
        <div class="form-group">
          <label class="form-label">Percentile (optional)</label>
          <input type="number" id="racePercentile" class="form-input" placeholder="30" step="1" min="1" max="100">
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Notes (optional)</label>
        <textarea id="raceNotes" class="form-input" rows="3" placeholder="Any notes about conditions, obstacles, etc."></textarea>
      </div>

      <div style="display: flex; gap: 12px; margin-top: 24px;">
        <button class="btn btn-success" onclick="saveRace()">Save Race</button>
        <button class="btn btn-secondary" onclick="closeAddRaceModal()">Cancel</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let athleteProfile = null;
    let currentRaces = [];
    let editingRaceIndex = -1;

    // Base speeds from athlete profile
    const ATHLETE = {
      speeds: {
        steep_d: 5.92,
        mod_d: 6.96,
        flat: 6.62,
        mod_u: 4.95,
        steep_u: 3.71
      },
      tech_skill: 0.96
    };

    // CTL to Fitness conversion baseline
    // Based on: UTMB 2025 CTL 120 = fitness 1.0
    //           Arc 2025 CTL 146 = fitness 1.21
    const CTL_BASELINE = {
      baseline_ctl: 120,
      baseline_fitness: 1.0,
      ctl_to_fitness_factor: 0.00808  // (1.21 - 1.0) / (146 - 120) = 0.21 / 26
    };

    // Calculate fitness from CTL
    function calculateFitnessFromCTL() {
      const ctl = parseFloat(document.getElementById('raceCTL').value);
      if (!ctl || isNaN(ctl)) {
        return;
      }

      // Allow override from athlete profile if available
      let baselineCTL = CTL_BASELINE.baseline_ctl;
      let baselineFitness = CTL_BASELINE.baseline_fitness;
      let factor = CTL_BASELINE.ctl_to_fitness_factor;

      if (athleteProfile?.fitness_baseline) {
        baselineCTL = athleteProfile.fitness_baseline.training_load_at_baseline?.ctl_chronic_training_load || baselineCTL;
        baselineFitness = athleteProfile.fitness_baseline.fitness_level_baseline || baselineFitness;
        // Recalculate factor if we have another data point
        // Using Arc 2025: CTL 146 = fitness 1.21 as second point
        factor = 0.00808;
      }

      const fitness = baselineFitness + (ctl - baselineCTL) * factor;
      document.getElementById('raceFitness').value = fitness.toFixed(3);
      console.log(`CTL ${ctl} ‚Üí Fitness ${fitness.toFixed(3)}`);
    }

    // Load athlete profile
    document.getElementById('profileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          athleteProfile = JSON.parse(evt.target.result);
          document.getElementById('profileStatus').innerText = `‚úÖ Loaded: ${athleteProfile.athlete_info?.name || 'Unknown'}`;
          loadRaces();
          loadAthleteDetails();
          showCards();
          calculateCalibration();
        } catch(err) {
          alert('Error loading profile: ' + err.message);
        }
      };
      reader.readAsText(file);
    });

    function loadRaces() {
      currentRaces = [];
      if (athleteProfile.athlete_info && athleteProfile.athlete_info.race_history) {
        currentRaces = athleteProfile.athlete_info.race_history.map(race => {
          let fitness = race.fitness_level;
          let ctl = race.ctl;

          // Auto-calculate fitness from CTL if fitness not provided
          if (!fitness && ctl) {
            fitness = CTL_BASELINE.baseline_fitness + (ctl - CTL_BASELINE.baseline_ctl) * CTL_BASELINE.ctl_to_fitness_factor;
            console.log(`Auto-calculated fitness ${fitness.toFixed(3)} from CTL ${ctl} for ${race.race}`);
          }

          return {
            name: race.race,
            date: race.date,
            type: race.type,
            courseType: getCourseTypeFromRace(race),
            distance_km: race.distance_km,
            elevation_m: race.elevation_m,
            actual_time_hours: race.finish_time ? parseTimeToHours(race.finish_time) : race.actual_time_hours,
            fitness: fitness,
            ctl: ctl,
            temperature: race.conditions?.match(/(\d+)¬∞C/)?.[1],
            percentile: race.percentile,
            notes: race.notes || race.key_insights?.join('; '),
            isPrimary: race.status?.includes('BASELINE') || race.rank === 1
          };
        });
      }
    }

    function getCourseTypeFromRace(race) {
      const type = race.type?.toLowerCase() || '';
      const dist = race.distance_km || 0;
      const elevDensity = race.elevation_m / dist; // m per km

      // Road races
      if (type.includes('road')) {
        if (dist <= 5) return 'road_5k';
        if (dist <= 10) return 'road_10k';
        if (dist <= 21.1) return 'road_half_marathon';
        if (dist <= 42.2) return 'road_marathon';
        return 'road_ultra';
      }

      // Fell/Vertical races
      if (type.includes('fell') || type.includes('vertical') || type.includes('sky')) {
        if (type.includes('vertical')) return 'vertical_km';
        if (type.includes('sky')) return 'skyrunning';
        return 'fell_race';
      }

      // Alpine ultra
      if (type.includes('alpine') || dist > 150 || (dist > 100 && elevDensity > 50)) {
        return 'alpine_ultra_150_200k';
      }

      // Technical mountain
      if (type.includes('technical') || type.includes('mountain')) {
        if (dist > 70) return 'technical_mountain_long';
        return 'technical_mountain_50_70k';
      }

      // Trail races - categorize by distance and elevation density
      if (type.includes('trail')) {
        // Flat trail (< 20m/km)
        if (elevDensity < 20) {
          if (dist < 30) return 'flat_trail_short';
          if (dist < 50) return 'flat_trail_medium';
          return 'runnable_trail_40_80k';
        }
        // Hilly trail (20-40m/km)
        else if (elevDensity < 40) {
          if (dist < 30) return 'hilly_trail_short';
          if (dist < 50) return 'hilly_trail_medium';
          if (dist < 80) return 'hilly_trail_long';
          return 'technical_mountain_50_70k';
        }
        // Mountain trail (> 40m/km)
        else {
          if (dist < 70) return 'technical_mountain_50_70k';
          return 'technical_mountain_long';
        }
      }

      // Default fallback based on distance and elevation
      if (elevDensity < 20) {
        if (dist < 50) return 'flat_trail_medium';
        return 'runnable_trail_40_80k';
      } else if (elevDensity < 40) {
        return 'hilly_trail_medium';
      } else {
        return 'technical_mountain_50_70k';
      }
    }

    function parseTimeToHours(timeStr) {
      // Handle formats: "4:23:00", "38:04:32", etc.
      const parts = timeStr.split(':');
      if (parts.length === 3) {
        return parseInt(parts[0]) + parseInt(parts[1])/60 + parseInt(parts[2])/3600;
      }
      return parseFloat(timeStr);
    }

    function showCards() {
      document.getElementById('athleteDetailsCard').style.display = 'block';
      document.getElementById('metricsCard').style.display = 'block';
      document.getElementById('raceTableCard').style.display = 'block';
      document.getElementById('chartCard').style.display = 'block';
    }

    function saveAthleteDetails() {
      if (!athleteProfile) {
        alert('Please load an athlete profile first');
        return;
      }

      if (!athleteProfile.athlete_info) athleteProfile.athlete_info = {};

      athleteProfile.athlete_info.name = document.getElementById('athleteName').value || '';
      athleteProfile.athlete_info.location = document.getElementById('athleteLocation').value || '';

      if (!athleteProfile.athlete_info.racing_experience) {
        athleteProfile.athlete_info.racing_experience = {};
      }

      athleteProfile.athlete_info.racing_experience.primary_discipline = document.getElementById('athleteDiscipline').value || '';
      athleteProfile.athlete_info.racing_experience.strengths = document.getElementById('athleteStrengths').value.split(',').map(s => s.trim()).filter(s => s);
      athleteProfile.athlete_info.racing_experience.constraints = document.getElementById('athleteLimitations').value.split(',').map(s => s.trim()).filter(s => s);
      athleteProfile.athlete_info.racing_experience.racing_style_notes = document.getElementById('athleteNotes').value || '';

      alert('‚úÖ Athlete details saved to profile!');
      console.log('Athlete details saved:', athleteProfile.athlete_info);
    }

    function loadAthleteDetails() {
      if (!athleteProfile || !athleteProfile.athlete_info) return;

      const info = athleteProfile.athlete_info;
      document.getElementById('athleteName').value = info.name || '';
      document.getElementById('athleteLocation').value = info.location || '';

      if (info.racing_experience) {
        document.getElementById('athleteDiscipline').value = info.racing_experience.primary_discipline || '';
        document.getElementById('athleteStrengths').value = Array.isArray(info.racing_experience.strengths)
          ? info.racing_experience.strengths.join(', ')
          : '';
        document.getElementById('athleteLimitations').value = Array.isArray(info.racing_experience.constraints)
          ? info.racing_experience.constraints.join(', ')
          : '';
        document.getElementById('athleteNotes').value = info.racing_experience.racing_style_notes || '';
      }

      console.log('‚úÖ Loaded athlete details from profile');
    }

    function showAddRaceModal() {
      document.getElementById('addRaceModal').style.display = 'block';
      editingRaceIndex = -1;
      clearRaceForm();
    }

    function closeAddRaceModal() {
      document.getElementById('addRaceModal').style.display = 'none';
      clearRaceForm();
    }

    function clearRaceForm() {
      document.getElementById('raceName').value = '';
      document.getElementById('raceDate').value = '';
      document.getElementById('courseType').value = 'runnable_trail_40_80k';
      document.getElementById('raceDistance').value = '';
      document.getElementById('raceElevation').value = '';
      document.getElementById('raceTime').value = '';
      document.getElementById('raceFitness').value = '';
      document.getElementById('raceCTL').value = '';
      document.getElementById('raceTemp').value = '';
      document.getElementById('racePercentile').value = '';
      document.getElementById('raceNotes').value = '';
    }

    function saveRace() {
      const ctlValue = document.getElementById('raceCTL').value;
      const fitnessValue = document.getElementById('raceFitness').value;

      // If CTL is provided, use it; otherwise require fitness
      let ctl = ctlValue ? parseInt(ctlValue) : null;
      let fitness = fitnessValue ? parseFloat(fitnessValue) : null;

      // Auto-calculate fitness from CTL if not manually overridden
      if (ctl && !fitnessValue) {
        fitness = CTL_BASELINE.baseline_fitness + (ctl - CTL_BASELINE.baseline_ctl) * CTL_BASELINE.ctl_to_fitness_factor;
      }

      const race = {
        name: document.getElementById('raceName').value,
        date: document.getElementById('raceDate').value,
        courseType: document.getElementById('courseType').value,
        distance_km: parseFloat(document.getElementById('raceDistance').value),
        elevation_m: parseFloat(document.getElementById('raceElevation').value),
        actual_time_hours: parseTimeToHours(document.getElementById('raceTime').value),
        fitness: fitness,
        ctl: ctl,
        temperature: document.getElementById('raceTemp').value ? parseFloat(document.getElementById('raceTemp').value) : null,
        percentile: document.getElementById('racePercentile').value ? parseInt(document.getElementById('racePercentile').value) : null,
        notes: document.getElementById('raceNotes').value,
        isPrimary: false
      };

      if (!race.name || !race.date || !race.distance_km || !race.elevation_m || !race.actual_time_hours) {
        alert('Please fill in all required fields (*)');
        return;
      }

      if (!race.ctl && !race.fitness) {
        alert('Please provide either CTL or Fitness Level');
        return;
      }

      if (editingRaceIndex >= 0) {
        currentRaces[editingRaceIndex] = race;
      } else {
        currentRaces.push(race);
      }

      closeAddRaceModal();
      calculateCalibration();
    }

    function editRace(index) {
      const race = currentRaces[index];
      editingRaceIndex = index;

      document.getElementById('raceName').value = race.name;
      document.getElementById('raceDate').value = race.date;
      document.getElementById('courseType').value = race.courseType;
      document.getElementById('raceDistance').value = race.distance_km;
      document.getElementById('raceElevation').value = race.elevation_m;
      document.getElementById('raceTime').value = formatHoursToTime(race.actual_time_hours);
      document.getElementById('raceFitness').value = race.fitness;
      document.getElementById('raceCTL').value = race.ctl || '';
      document.getElementById('raceTemp').value = race.temperature || '';
      document.getElementById('racePercentile').value = race.percentile || '';
      document.getElementById('raceNotes').value = race.notes || '';

      document.getElementById('addRaceModal').style.display = 'block';
    }

    function deleteRace(index) {
      if (confirm('Are you sure you want to delete this race?')) {
        currentRaces.splice(index, 1);
        calculateCalibration();
      }
    }

    function togglePrimary(index) {
      // Only one primary race allowed
      currentRaces.forEach((r, i) => {
        r.isPrimary = (i === index);
      });
      calculateCalibration();
    }

    function formatHoursToTime(hours) {
      const h = Math.floor(hours);
      const m = Math.floor((hours - h) * 60);
      const s = Math.floor(((hours - h) * 60 - m) * 60);
      return `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function calculateCalibration() {
      if (currentRaces.length === 0) {
        alert('No races to calibrate. Add races first.');
        return;
      }

      // Calculate predicted time for each race using different calibration attempts
      const calibrationRange = [];
      for (let factor = 1.0; factor <= 2.0; factor += 0.01) {
        let totalError = 0;
        let weightSum = 0;

        currentRaces.forEach(race => {
          const predicted = predictRaceTime(race, factor);
          const error = Math.abs(predicted - race.actual_time_hours);
          const weight = calculateWeight(race);

          totalError += error * weight;
          weightSum += weight;
        });

        const meanError = totalError / weightSum;
        calibrationRange.push({ factor: factor, meanError: meanError });
      }

      // Find optimal factor
      calibrationRange.sort((a, b) => a.meanError - b.meanError);
      const optimalFactor = calibrationRange[0].factor;

      // Calculate by course type - get all unique types from current races
      const courseTypeFactors = {};
      const courseTypes = [...new Set(currentRaces.map(r => r.courseType))];

      courseTypes.forEach(courseType => {
        const racesOfType = currentRaces.filter(r => r.courseType === courseType);
        if (racesOfType.length === 0) {
          courseTypeFactors[courseType] = optimalFactor;
          return;
        }

        const typeCalibration = [];
        for (let factor = 0.8; factor <= 2.0; factor += 0.01) {
          let totalError = 0;
          let weightSum = 0;

          racesOfType.forEach(race => {
            const predicted = predictRaceTime(race, factor);
            const error = Math.abs(predicted - race.actual_time_hours);
            const weight = calculateWeight(race);

            totalError += error * weight;
            weightSum += weight;
          });

          const meanError = weightSum > 0 ? totalError / weightSum : 999;
          typeCalibration.push({ factor: factor, meanError: meanError });
        }

        typeCalibration.sort((a, b) => a.meanError - b.meanError);
        courseTypeFactors[courseType] = typeCalibration[0].factor;
      });

      // Calculate overall mean error with optimal factor
      let totalError = 0;
      let weightSum = 0;
      currentRaces.forEach(race => {
        const factor = courseTypeFactors[race.courseType] || optimalFactor;
        const predicted = predictRaceTime(race, factor);
        const error = Math.abs(predicted - race.actual_time_hours);
        const weight = calculateWeight(race);

        totalError += error * weight;
        weightSum += weight;
      });
      const meanError = totalError / weightSum;

      // Update UI
      document.getElementById('overallFactor').innerText = optimalFactor.toFixed(3);
      document.getElementById('meanError').innerText = (meanError * 60).toFixed(1) + 'm';
      document.getElementById('totalRaces').innerText = currentRaces.length;

      const confidence = Math.max(0, Math.min(1, 1 - meanError * 2));
      document.getElementById('confidence').innerText = (confidence * 100).toFixed(0) + '%';

      // Display course type factors
      displayCourseTypeFactors(courseTypeFactors);

      // Update race table
      updateRaceTable(courseTypeFactors);

      // Update chart
      updateChart(courseTypeFactors);

      // Store in profile
      if (!athleteProfile.calibration) athleteProfile.calibration = {};
      athleteProfile.calibration.overall_factor = optimalFactor;
      athleteProfile.calibration.by_course_type = courseTypeFactors;
      athleteProfile.calibration.mean_error_minutes = meanError * 60;
      athleteProfile.calibration.confidence = confidence;
      athleteProfile.calibration.last_calculated = new Date().toISOString();
    }

    function predictRaceTime(race, calibrationFactor) {
      // Simplified prediction model using gradient-averaged speed
      // This is a rough approximation - the full model would need GPX data

      const avgGradient = (race.elevation_m / race.distance_km) / 10; // Convert to %

      let baseSpeed;
      if (avgGradient < -10) baseSpeed = ATHLETE.speeds.steep_d;
      else if (avgGradient < -3) baseSpeed = ATHLETE.speeds.mod_d;
      else if (avgGradient < 3) baseSpeed = ATHLETE.speeds.flat;
      else if (avgGradient < 10) baseSpeed = ATHLETE.speeds.mod_u;
      else baseSpeed = ATHLETE.speeds.steep_u;

      const speed = baseSpeed * race.fitness * ATHLETE.tech_skill * calibrationFactor;
      const predictedTime = race.distance_km / speed;

      return predictedTime;
    }

    function calculateWeight(race) {
      let weight = 1.0;

      // Primary race = 2x weight
      if (race.isPrimary) weight *= 2.0;

      // Recency weight (more recent = higher weight)
      const raceDate = new Date(race.date);
      const now = new Date();
      const daysSince = (now - raceDate) / (1000 * 60 * 60 * 24);
      const recencyWeight = Math.exp(-daysSince / 365); // Decay over 1 year
      weight *= (0.5 + 0.5 * recencyWeight); // Range: 0.5 to 1.0

      // Confidence weight (based on percentile if available)
      if (race.percentile) {
        const confidenceScore = 1.0 - Math.abs(race.percentile - 50) / 100;
        weight *= (0.8 + 0.2 * confidenceScore);
      }

      return weight;
    }

    function displayCourseTypeFactors(factors) {
      const container = document.getElementById('courseTypeFactors');
      container.innerHTML = '';

      const typeNames = {
        'road_5k': 'Road 5K',
        'road_10k': 'Road 10K',
        'road_half_marathon': 'Road Half',
        'road_marathon': 'Road Marathon',
        'road_ultra': 'Road Ultra',
        'flat_trail_short': 'Flat Trail (Short)',
        'flat_trail_medium': 'Flat Trail (Med)',
        'runnable_trail_40_80k': 'Runnable Trail',
        'hilly_trail_short': 'Hilly Trail (Short)',
        'hilly_trail_medium': 'Hilly Trail (Med)',
        'hilly_trail_long': 'Hilly Trail (Long)',
        'technical_mountain_50_70k': 'Tech Mountain',
        'technical_mountain_long': 'Tech Mtn (Long)',
        'alpine_ultra_150_200k': 'Alpine Ultra',
        'fell_race': 'Fell Race',
        'vertical_km': 'Vertical KM',
        'skyrunning': 'Skyrunning'
      };

      Object.keys(factors).forEach(type => {
        const div = document.createElement('div');
        div.style.cssText = 'background: #f9fafb; border-radius: 12px; padding: 16px; border: 2px solid #e5e7eb;';
        div.innerHTML = `
          <div style="font-size: 11px; color: #6b7280; font-weight: 600; margin-bottom: 4px;">${typeNames[type]}</div>
          <div style="font-size: 24px; font-weight: 900; color: #1f2937;">${factors[type].toFixed(3)}</div>
          <div style="font-size: 10px; color: #9ca3af; margin-top: 4px;">${currentRaces.filter(r => r.courseType === type).length} races</div>
        `;
        container.appendChild(div);
      });
    }

    function updateRaceTable(courseTypeFactors) {
      const tbody = document.getElementById('raceTableBody');
      tbody.innerHTML = '';

      // Get overall factor as fallback
      const overallFactor = athleteProfile?.calibration?.overall_factor || 1.35;

      currentRaces.forEach((race, index) => {
        const factor = courseTypeFactors[race.courseType] || overallFactor;
        const predicted = predictRaceTime(race, factor);
        const errorPct = ((predicted - race.actual_time_hours) / race.actual_time_hours) * 100;

        let errorClass = 'accuracy-good';
        if (Math.abs(errorPct) > 5) errorClass = 'accuracy-ok';
        if (Math.abs(errorPct) > 10) errorClass = 'accuracy-bad';

        const row = document.createElement('tr');
        row.innerHTML = `
          <td><input type="checkbox" ${race.isPrimary ? 'checked' : ''} onchange="togglePrimary(${index})"></td>
          <td><strong>${race.name}</strong></td>
          <td>${race.date}</td>
          <td><span class="badge badge-primary">${race.courseType.replace(/_/g, ' ')}</span></td>
          <td>${race.distance_km}km</td>
          <td>${race.elevation_m}m</td>
          <td>${formatHoursToTime(race.actual_time_hours)}</td>
          <td>${formatHoursToTime(predicted)}</td>
          <td class="${errorClass}">${errorPct >= 0 ? '+' : ''}${errorPct.toFixed(1)}%</td>
          <td>${race.ctl || '-'}</td>
          <td>${race.fitness.toFixed(2)}</td>
          <td class="action-buttons">
            <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 11px;" onclick="editRace(${index})">Edit</button>
            <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;" onclick="deleteRace(${index})">Delete</button>
          </td>
        `;
        tbody.appendChild(row);
      });
    }

    function updateChart(courseTypeFactors) {
      console.log('updateChart called with', currentRaces.length, 'races');

      const canvas = document.getElementById('accuracyChart');
      if (!canvas) {
        console.error('Canvas element not found');
        return;
      }

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Could not get 2D context');
        return;
      }

      // Get overall factor as fallback
      const overallFactor = athleteProfile?.calibration?.overall_factor || 1.35;

      const labels = currentRaces.map(r => r.name);
      const actual = currentRaces.map(r => r.actual_time_hours);
      const predicted = currentRaces.map(r => {
        const factor = courseTypeFactors[r.courseType] || overallFactor;
        return predictRaceTime(r, factor);
      });

      console.log('Chart data:', { labels, actual, predicted });

      // Destroy existing chart
      if (window.accuracyChart) {
        window.accuracyChart.destroy();
      }

      try {
        window.accuracyChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Actual Time (hours)',
                data: actual,
                backgroundColor: 'rgba(59, 130, 246, 0.8)',
                borderColor: '#3b82f6',
                borderWidth: 2
              },
              {
                label: 'Predicted Time (hours)',
                data: predicted,
                backgroundColor: 'rgba(16, 185, 129, 0.8)',
                borderColor: '#10b981',
                borderWidth: 2
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top'
              },
              title: {
                display: true,
                text: 'Actual vs Predicted Race Times',
                font: {
                  size: 16,
                  weight: 'bold'
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Time (hours)',
                  font: {
                    size: 14,
                    weight: 'bold'
                  }
                },
                ticks: {
                  callback: function(value) {
                    return value.toFixed(1) + 'h';
                  }
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Race',
                  font: {
                    size: 14,
                    weight: 'bold'
                  }
                },
                ticks: {
                  maxRotation: 45,
                  minRotation: 45
                }
              }
            }
          }
        });

        // Hide placeholder
        const placeholder = document.getElementById('chartPlaceholder');
        if (placeholder) placeholder.style.display = 'none';

        console.log('‚úÖ Chart created successfully');
      } catch (err) {
        console.error('Error creating chart:', err);

        // Show error in placeholder
        const placeholder = document.getElementById('chartPlaceholder');
        if (placeholder) {
          placeholder.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 12px; color: #ef4444;">‚ö†Ô∏è</div>
            <div style="font-size: 14px; font-weight: 600; color: #dc2626;">Chart Error</div>
            <div style="font-size: 12px; margin-top: 8px;">${err.message}</div>
            <div style="font-size: 11px; margin-top: 8px; color: #6b7280;">Check browser console for details</div>
          `;
        }
      }
    }

    function exportProfile() {
      if (!athleteProfile) {
        alert('No profile loaded');
        return;
      }

      // Update race history in profile
      athleteProfile.athlete_info.race_history = currentRaces.map((race, index) => ({
        rank: index + 1,
        race: race.name,
        date: race.date,
        type: race.courseType,
        distance_km: race.distance_km,
        elevation_m: race.elevation_m,
        finish_time: formatHoursToTime(race.actual_time_hours),
        fitness_level: race.fitness,
        ctl: race.ctl,
        percentile: race.percentile,
        conditions: race.temperature ? `${race.temperature}¬∞C` : undefined,
        notes: race.notes,
        status: race.isPrimary ? 'BASELINE CALIBRATION RACE' : undefined
      }));

      // Update metadata
      if (!athleteProfile.metadata) athleteProfile.metadata = {};
      athleteProfile.metadata.last_updated = new Date().toISOString().split('T')[0];
      athleteProfile.metadata.calibration_status = `${currentRaces.length} races`;

      // Download
      const blob = new Blob([JSON.stringify(athleteProfile, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${athleteProfile.athlete_info?.name || 'athlete'}_profile_calibrated.json`;
      a.click();
      URL.revokeObjectURL(url);

      alert('Profile exported successfully!');
    }

    // GPX upload handler
    document.getElementById('gpxInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const parser = new DOMParser();
          const xml = parser.parseFromString(evt.target.result, 'text/xml');

          // Extract name from metadata or filename
          let name = xml.querySelector('metadata name')?.textContent || file.name.replace('.gpx', '');
          document.getElementById('raceName').value = name;

          // Extract time from metadata
          const timeElement = xml.querySelector('metadata time');
          if (timeElement) {
            const date = new Date(timeElement.textContent);
            document.getElementById('raceDate').value = date.toISOString().split('T')[0];
          }

          // Calculate distance and elevation from trackpoints
          const points = Array.from(xml.querySelectorAll('trkpt'));
          if (points.length > 0) {
            let totalDist = 0;
            let totalElevGain = 0;
            let prevLat = null, prevLon = null, prevEle = null;
            let firstTime = null, lastTime = null;

            points.forEach((point, index) => {
              const lat = parseFloat(point.getAttribute('lat'));
              const lon = parseFloat(point.getAttribute('lon'));
              const ele = parseFloat(point.querySelector('ele')?.textContent || 0);

              // Extract time from trackpoint
              const timeElement = point.querySelector('time');
              if (timeElement) {
                const pointTime = new Date(timeElement.textContent);
                if (index === 0) {
                  firstTime = pointTime;
                }
                lastTime = pointTime;
              }

              if (prevLat !== null) {
                // Haversine distance
                const R = 6371; // Earth radius in km
                const dLat = (lat - prevLat) * Math.PI / 180;
                const dLon = (lon - prevLon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(prevLat * Math.PI / 180) * Math.cos(lat * Math.PI / 180) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDist += R * c;

                // Elevation gain
                if (prevEle !== null && ele > prevEle) {
                  totalElevGain += ele - prevEle;
                }
              }

              prevLat = lat;
              prevLon = lon;
              prevEle = ele;
            });

            document.getElementById('raceDistance').value = totalDist.toFixed(1);
            document.getElementById('raceElevation').value = Math.round(totalElevGain);

            // Calculate and populate finish time if timestamps available
            if (firstTime && lastTime) {
              const durationMs = lastTime - firstTime;
              const durationHours = durationMs / (1000 * 60 * 60);
              const hours = Math.floor(durationHours);
              const minutes = Math.floor((durationHours - hours) * 60);
              const seconds = Math.floor(((durationHours - hours) * 60 - minutes) * 60);
              const timeStr = `${hours}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
              document.getElementById('raceTime').value = timeStr;
              console.log(`‚úÖ Extracted finish time: ${timeStr} (${durationHours.toFixed(2)} hours)`);
            }
          }

          // Show appropriate message based on what was extracted
          const extractedFields = ['distance', 'elevation'];
          if (firstTime && lastTime) extractedFields.push('finish time');
          alert(`GPX data extracted: ${extractedFields.join(', ')}! Please fill in remaining fields.`);
        } catch(err) {
          alert('Error parsing GPX: ' + err.message);
        }
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
